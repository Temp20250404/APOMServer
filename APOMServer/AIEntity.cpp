
#include "AIEntity.h"
#include "RoomManager.h"
#include "Player.h"

UINT32 AIEntity::g_id = 1;

AIEntity::AIEntity(const AIContext& aiContext, BTBuilder builder)
    : m_id(g_id++)
    , m_context(aiContext)
    , m_behaviorTree(nullptr)
{
    m_context.ID = m_id;

    //m_context.ptargetRoom = aiContext.ptargetRoom;

    // 전달받은 builder 함수를 사용하여 행동 트리 생성
    m_behaviorTree = builder(m_context);
}

AIEntity::~AIEntity()
{
    delete m_behaviorTree;
}

void AIEntity::Update()
{
    // 가장 가까운 플레이어를 타겟으로 설정. 나중에 어그로 게이지 같은 기능이 추가되면 여기만 건들이면 끝
    UpdateTarget();

    NodeStatus status = m_behaviorTree->Tick();
    if (status != NodeStatus::RUNNING)
        m_behaviorTree->Initialize();
}

void AIEntity::UpdateTarget()
{
    // 방 정보가 없으면 바로 리턴
    if (m_context.ptargetRoom == nullptr)
        return;

    // 보스의 현재 위치
    float bossX = m_context.currentPos.posX;
    float bossY = m_context.currentPos.posY;
    float bossZ = m_context.currentPos.posZ;

    float closestDistance = FLT_MAX;
    CPlayer* closestPlayer = nullptr;

    // 방에 있는 모든 활성 플레이어에 대해 반복
    const std::vector<CPlayer*>& activePlayers = m_context.ptargetRoom->GetActivePlayers();
    for (CPlayer* player : activePlayers)
    {
        float px, py, pz;
        player->getPosition(px, py, pz);

        // 유클리드 거리를 계산
        float distance = std::sqrt((bossX - px) * (bossX - px) +
            (bossY - py) * (bossY - py) +
            (bossZ - pz) * (bossZ - pz));

        // 인지 범위보다 플레이어와의 거리가 짧다면
        if (m_context.detectionRange > distance)
        {
            // 갱신
            if (distance < closestDistance)
            {
                closestDistance = distance;
                closestPlayer = player;
            }
        }
    }

    // 가장 가까운 플레이어를 타겟으로 설정
    m_context.pTargetPlayer = closestPlayer;

    if (m_context.pTargetPlayer)
    {
        std::cout << "플레이어 감지됨. 거리 : " << closestDistance << "\n";

        m_context.hasTargetPlayer = true;
        m_context.playerDistance = closestDistance;

        float px, py, pz;
        m_context.pTargetPlayer->getPosition(px, py, pz);
        m_context.targetPos = Position{ px, py, pz };
        std::cout << "타겟 위치 갱신 : " << px << ", " << py << ", " << pz << "\n";
    }
    else
    {
        std::cout << "플레이어 감지되지 않음\n";

        m_context.hasTargetPlayer = false;
        m_context.playerDistance = 0.f;
    }
}

void AIEntity::GetDamaged(UINT damage)
{
    m_context.currentHP -= damage;

    if (m_context.currentHP <= 0)
        m_context.currentHP = 0;
}
